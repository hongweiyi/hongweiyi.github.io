<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Netty 4.x学习笔记 - Channel和Pipeline · 小e的笔记</title><meta name="description" content="1、前言Channel概念与java.nio.channel概念一致，用以连接IO设备（socket、文件等）的纽带。Netty 4.x之后的Channel变化较大，官方的唬人的说法是无法通过简单的关键字替换进行迁移。用得较多应该是：ChannelHandler接口重新设计，换了个较为清晰的名字；write不会主动flush。由于笔者3.x、4.x都没用过，所以也无法深入理解版本的变化了。


关于channel 4.x的新变化可以参考这里：new and noteworthy: Channel API changes

2、Channel总览

Channel的IO类型主要有两种：非阻塞IO（NIO）以及阻塞IO（OIO）；数据传输类型有两种：按事件消息传递（Message）以及按字节传递（Byte）；适用方类型也有两种：服务器（ServerSocket）"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="http://weibo.com/1674333040" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://twitter.com/hongwei89" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Netty 4.x学习笔记 - Channel和Pipeline</h1><div class="post-meta"><div class="post-time">Jan 7, 2014 | [<a class="tag-link" href="/tags/Netty/">Netty</a>]</div></div><div class="post-content"><h3 id="1、前言">1、前言</h3><p>Channel概念与java.nio.channel概念一致，用以连接IO设备（socket、文件等）的纽带。Netty 4.x之后的Channel变化较大，官方的唬人的说法是无法通过简单的关键字替换进行迁移。用得较多应该是：ChannelHandler接口重新设计，换了个较为清晰的名字；write不会主动flush。由于笔者3.x、4.x都没用过，所以也无法深入理解版本的变化了。</p>
<a id="more"></a>
<blockquote>
<p>关于channel 4.x的新变化可以参考这里：new and noteworthy: Channel API changes</p>
</blockquote>
<h3 id="2、Channel总览">2、Channel总览</h3><center><div style="width: 80%;"><img src="/images/wpid-Channel.png" alt="Netty Channel整体结构思维导图"></div></center>

<p>Channel的IO类型主要有两种：非阻塞IO（NIO）以及阻塞IO（OIO）；数据传输类型有两种：按事件消息传递（Message）以及按字节传递（Byte）；适用方类型也有两种：服务器（ServerSocket）以及客户端（Socket）。还有一些根据传输协议而制定的的Channel，如：UDT、SCTP等。</p>
<p>Netty按照类型逐层设计相应的类。最底层的为抽象类AbstractChannel，再以此根据IO类型、数据传输类型、适用方类型实现。类图可以一目了然，如下图所示：</p>
<center><div style="width: 80%;"><img src="/images/wpid-nio-oio.jpg" alt="Netty Channel类图"></div></center>

<h3 id="3、ChannelPipeline实现分析">3、ChannelPipeline实现分析</h3><p>从AbstractChannel分析，它提供了一些IO操作方法，read、write等，Channel仅仅做了一个封装，方法中将参数直接传递给了Channel的Pipeline成员的相应方法。</p>
<p>Pipeline则是Channel里面非常重要的概念。从数据结构的角度，它是一个双向链表，每个节点均是DefaultChannelHandlerContext对象；从逻辑的角度，它则是netty的逻辑处理链，每个节点均包含一个逻辑处理器（ChannelHandler），用以实现网络通信的编/解码、处理等功能。</p>
<p>Pipeline的链表上有两种handler，Inbound Handler和Outbound handler。从Netty内部IO线程接读到IO数据，依次经过N个Handler到达最内部的逻辑处理单元，这种称之为Inbound Handler；从Channel发出IO请求，依次经过M个Handler到达Netty内部IO线程，这种称之为Outbound Handler。内部代码实现流程则是：Head -&gt; Tail (Inbound)，Tail -&gt; Head (Outbound)。下图截取自ChannelPipeline的注释中，简单明了：</p>
<center><div style="width: 60%;"><img src="/images/wpid-Netty-ChannelPipeline-.png" alt="Netty Pipeline"></div></center>

<h3 id="4、逻辑处理器">4、逻辑处理器</h3><p>ChannelPipeline仅仅只是逻辑处理的流程，真正逻辑处理器则是ChannelHandlerInvoker。在获得链表节点后，节点会调用自己的invoker成员执行(invoke)逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    DefaultChannelHandlerContext next = findContextOutbound();</span><br><span class="line">    next.invoker.invokeWriteAndFlush(next, msg, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DefaultChannelHandlerInvoker中只有一个成员(executor)，执行逻辑的过程中，Invoker会先判断当前运行线程是否是executor，如果是则直接运行相应方法，不是则启动子线程运行相应方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite</span><span class="params">(ChannelHandlerContext ctx, Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123; <span class="comment">// 判断是否是当前线程</span></span><br><span class="line">        invokeWriteNow(ctx, msg, promise);</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            invokeFlushNow(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AbstractChannel channel = (AbstractChannel) ctx.channel();</span><br><span class="line">        <span class="keyword">int</span> size = channel.estimatorHandle().size(msg);</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ChannelOutboundBuffer buffer = channel.unsafe().outboundBuffer();</span><br><span class="line">            <span class="comment">// Check for null as it may be set to null if the channel is closed already</span></span><br><span class="line">            <span class="keyword">if</span> (buffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                buffer.incrementPendingOutboundBytes(size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个新的WriteTask</span></span><br><span class="line">        <span class="comment">// executor.execute(task);</span></span><br><span class="line">        safeExecuteOutbound(WriteTask.newInstance(ctx, msg, size, flush, promise), promise, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>executor继承自<a href="http://netty.io/4.0/api/io/netty/util/concurrent/EventExecutor.html" target="_blank" rel="external">EventExecutor</a>，同时，该对象实现类一般而言也是实现<a href="http://netty.io/4.0/api/io/netty/channel/EventLoop.html" target="_blank" rel="external">EventLoop</a>接口。EventLoop的实现体现了Netty 4.x的IO线程模型，非常重要，后面再详细解析。</p>
<h4 id="5、总结">5、总结</h4><p>至此，上面简单总结了Channel以及Pipeline的处理流程。<code>Channel.write -&gt; ChannelPipeline.write -&gt; ChannelHandlerContext.write -&gt; ChannelHandlerInvoker.write -&gt; ChannelHandler.write</code>。在这个过程中，我也是捡简单的、流程性的代码总结，像EventLoop、EventExecutor这种核心部分并没有深入总结，压后再详细解说。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/01/netty-4-x-thread-model/" class="prev">上一篇</a><a href="/2014/01/netty-4-x-bytebuf/" class="next">下一篇</a></div><div data-thread-key="2014/01/netty-4-x-channel-pipeline/" data-title="Netty 4.x学习笔记 - Channel和Pipeline" data-url="http://hongweiyi.com/2014/01/netty-4-x-channel-pipeline/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"yihongwei"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://hongweiyi.com">Hongwei Yi</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-66911097-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>