<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Shell常用命令 进程操作篇 · 小e的笔记</title><meta name="description" content="4.0 前言这篇算是尾篇了，命令较多也较繁杂，每个都是点到为止，基本也够用。有兴趣深入的朋友可自行谷歌学习。

4.1 进程执行进程执行无外乎前台运行，但是前台运行需要用户等待程序运行完毕才可继续，所以就有了后台运行进程这一说。后台进程又分两种，当前终端后台进程，以及托管给OS的后台进程。这里就稍微介绍一下如何运行这些个进程吧。

BTW: 以上分类都是我瞎分的，仅供参考。

后台运行进程:在运行命令末尾加上&amp;amp;符号，该程序就会在后台运行，如果忘记敲&amp;amp;命令的话，也可以同过ctrl+z，暂停当前进程，再用bg(backgroud)命令即可让暂停任务变成后台运行。
12"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="http://weibo.com/1674333040" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://twitter.com/hongwei89" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Shell常用命令 进程操作篇</h1><div class="post-meta"><div class="post-time">Jan 22, 2013 | [<a class="tag-link" href="/tags/Linux/">Linux</a>, <a class="tag-link" href="/tags/Shell/">Shell</a>]</div></div><div class="post-content"><h3 id="4-0_前言">4.0 前言</h3><p>这篇算是尾篇了，命令较多也较繁杂，每个都是点到为止，基本也够用。有兴趣深入的朋友可自行谷歌学习。</p>
<a id="more"></a>
<h3 id="4-1_进程执行">4.1 进程执行</h3><p>进程执行无外乎前台运行，但是前台运行需要用户等待程序运行完毕才可继续，所以就有了后台运行进程这一说。后台进程又分两种，当前终端后台进程，以及托管给OS的后台进程。这里就稍微介绍一下如何运行这些个进程吧。</p>
<blockquote>
<p>BTW: 以上分类都是我瞎分的，仅供参考。</p>
</blockquote>
<h4 id="后台运行进程:">后台运行进程:</h4><p>在运行命令末尾加上<code>&amp;</code>符号，该程序就会在后台运行，如果忘记敲<code>&amp;</code>命令的话，也可以同过ctrl+z，暂停当前进程，再用bg(backgroud)命令即可让暂停任务变成后台运行。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>/bin/sh your.sh &amp;</span><br><span class="line">[<span class="number">1</span>]    pid        <span class="comment"># 输出进程在当前终端的序号以及pid</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>/bin/sh your.sh       <span class="comment"># ctrl + z</span></span><br><span class="line">[<span class="number">1</span>]+  <span class="constant">Stopped</span>            /bin/sh your.sh</span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>bg %<span class="number">1</span>   <span class="comment"># %1 代表当前终端的第一个进程</span></span><br><span class="line">[<span class="number">1</span>]+  <span class="regexp">/bin/sh</span> your.sh &amp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TIPS: The plus sign shows the most recently invoked job; the minus sign shows the next most recently invoked job.- <learning the="" korn="" shell,="" 2nd="" edition=""></learning></p>
<p>WARNING: 当运行某个有大量输出的进程，如果直接让其进入后台运行是很不明智的，一般来说会将输出写入文件中。如： <code>$ /bin/sh your.sh &gt; ./your.log 2&gt;&amp;1 &amp;</code></p>
</blockquote>
<h4 id="前台运行进程：">前台运行进程：</h4><p>有了后台，就有相应的前台运行进程了。fg(foreground)就是了，但一般来说，很少需要将后台进程推到前台的需求，我一般是这样用的：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>vim your_file      <span class="comment"># ctrl + z</span></span><br><span class="line">[<span class="number">1</span>]+   <span class="constant">Stopped</span>            vim your_file</span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>fg %<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="托管进程：">托管进程：</h4><p>上面的命令均是在当前终端运行，如果终端关闭，相应的进程也关闭了，如果想进程继续运行，则需要将进程托管给系统管理。主要命令是nohup。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>nohup /bin/sh your.sh &amp;</span><br><span class="line">[<span class="number">1</span>]    pid</span><br><span class="line"><span class="symbol">nohup:</span> appending output to ‘nohup.out<span class="string">'</span></span><br></pre></td></tr></table></figure>
<p>实战的时候，更多的情况是这样的：突然有事要走开一下，又生怕跑了半天的程序因为终端挂了，想将其托管给系统。那么就可以用disown命令。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>/bin/sh your.sh &amp;</span><br><span class="line">[<span class="number">1</span>]    pid</span><br><span class="line"><span class="prompt">&gt;&gt;</span> disown %<span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>看这个解释得更为详细，我对其理解较为肤浅：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-nohup/" target="_blank" rel="external">Linux技巧：让后台在后台可靠运行的几种方法</a>。</p>
</blockquote>
<h4 id="screen:">screen:</h4><p>上面两个命令都不是最好用的，最好用的应该是screen命令了。screen 提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。screen用好了，感觉也不比tmux差多少。</p>
<p>要同时跑多个screen，并想快速切换的换，可以添加几个screen的alias。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> s=<span class="string">"screen"</span></span><br><span class="line"><span class="built_in">alias</span> sr=<span class="string">"screen -r"</span>     <span class="comment"># 连接到某个模拟器</span></span><br><span class="line"><span class="built_in">alias</span> sl=<span class="string">"screen -ls"</span>     <span class="comment"># 显示当前所有模拟器</span></span><br><span class="line"><span class="built_in">alias</span> sl=<span class="string">"screen -d"</span>     <span class="comment"># 强制断开某个模拟器连接</span></span><br><span class="line">ctrl+<span class="operator">a</span> :sessionname MyName   <span class="comment"># 在screen模拟器中，修改模拟器名字</span></span><br><span class="line">ctrl+<span class="operator">a</span> :<span class="built_in">kill</span>    <span class="comment"># 强制关闭模拟器（模拟器有时候会莫名其妙的没响应）</span></span><br><span class="line">ctrl+<span class="operator">a</span> :encoding gbk     <span class="comment"># 设置screen编码</span></span><br><span class="line">ctrl+<span class="operator">a</span> d     <span class="comment"># detached模拟器（就是临时退出）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>TIPS: screen终端ls文件没有颜色，是因为screen终端类型比较特殊，echo $TERM显示为screen或者screen.linux类型，解决方案是修改/etc/DIR_COLORS或者复制/etc/DIR_COLORS到~/.dir_colors，加入一句：&quot;TERM screen&quot;注销重登即可。</p>
</blockquote>
<h4 id="jobs:">jobs:</h4><p>列出当前终端运行的后台进程。</p>
<h4 id="ps:">ps:</h4><p>列出系统正在运行的程序。</p>
<h4 id="top:">top:</h4><p>理解为win下面的任务管理器，需要注意的地方应该是load average了，Load Average表示了CPU的Load，它所包含的信息不是 CPU的使用率状况，而是在一段时间内CPU正在处理以及等待CPU处理的进程数之和的统计信息，也就是 CPU使用队列的长度的统计信息。load average: 0.06, 0.60, 0.48，三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。需要注意，load average如果超过一定的数的话，系统负载较高。</p>
<p><code>Load Average &lt; CPU个数 * 核数 *0.7</code></p>
<p>我常用的命令也不多，如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>top</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>top -p pid [-p pid2 …]</span><br><span class="line">…    <span class="comment"># 只查看pid这个进程</span></span><br></pre></td></tr></table></figure>
<h4 id="crontab:">crontab:</h4><p>定时任务命令，这个东西有时候也折磨了好一段时间。内容格式说着也简单：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>crontab -e    <span class="comment"># 编辑定时任务列表</span></span><br><span class="line">cmd &gt; <span class="regexp">/dev/null</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span>     <span class="comment"># 5个分别代表分、时、日、月、周。需要将输出写到某个文件或者/dev/null中，因为它的所有输出均会按邮件发到服务器上，日积月累也是个负担</span></span><br><span class="line">/<span class="number">2</span> * cmd &gt; <span class="regexp">/dev/null</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span>     <span class="comment"># 代表每两分钟执行一次cmd</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>crontab -l    <span class="comment"># 显示定时任务列表</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>crontab -r    <span class="comment"># 删除定时任务列表（- -，不知道为什么要有这个选项）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>偷懒，直接贴其他人的帖子吧：<a href="http://www.cnblogs.com/cosiray/archive/2012/03/09/2387361.html" target="_blank" rel="external">Crontab 错误分析及不执行原因</a></p>
</blockquote>
<h4 id="history:">history:</h4><p>查看命令历史，以下是常用方法和有用的设置：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; $ <span class="keyword">history</span> | more</span><br><span class="line">&gt;&gt; $ <span class="keyword">history</span> | <span class="keyword">grep</span> <span class="keyword">ls</span></span><br><span class="line">&gt;&gt; $ <span class="keyword">vi</span> ~/.bashrc</span><br><span class="line">HISTFILESIZE=<span class="number">2000</span>     # <span class="keyword">history</span> 记录长度</span><br><span class="line">HISTTIMEFORMAT=<span class="string">'%F %T '</span>     # 给记录添加时间戳</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TIPS1: 输入命令前，输入一个空格，该记录不添加进history中</p>
<p>TIPS2: ctrl + r是找历史记录，查找过程中继续按ctrl+r是当前查找结果的上一条</p>
</blockquote>
<h4 id="ssh:">ssh:</h4><p>最后一个说ssh，好像也没啥说的。远程登录，远程拷贝</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>ssh -l user ip [-p port]</span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>ssh user<span class="variable">@ip</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>scp user<span class="variable">@ip</span><span class="symbol">:/src/dir/or/file</span> user<span class="variable">@ip</span><span class="symbol">:/dest/dir/or/file</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>FINAL TIPS: 拷贝的时候需要输入对方的用户密码，可以添加相关的密钥一劳永逸。但是添加密钥的方式有点微麻烦，所以可以用其他方式代替，那就是用expect命令。下面这段脚本可以实现无间断的远程push，可以自己改成远程pull。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line"><span class="built_in">set</span> user [lindex <span class="variable">$argv</span> <span class="number">0</span>]</span><br><span class="line"><span class="built_in">set</span> passwd [lindex <span class="variable">$argv</span> <span class="number">1</span>]</span><br><span class="line"><span class="built_in">set</span> ip [lindex <span class="variable">$argv</span> <span class="number">2</span>]</span><br><span class="line"><span class="built_in">set</span> src [lindex <span class="variable">$argv</span> <span class="number">3</span>]</span><br><span class="line"><span class="built_in">set</span> des [lindex <span class="variable">$argv</span> <span class="number">4</span>]</span><br><span class="line"><span class="built_in">set</span> timeout <span class="number">60</span></span><br><span class="line">spawn /usr/<span class="built_in">local</span>/bin/scp -r <span class="variable">$&#123;src&#125;</span> <span class="variable">$&#123;user&#125;</span>@<span class="variable">$&#123;ip&#125;</span>:<span class="variable">$&#123;des&#125;</span></span><br><span class="line">expect &#123;</span><br><span class="line">    <span class="string">"*assword:"</span> &#123;</span><br><span class="line">     send <span class="string">"<span class="variable">$&#123;passwd&#125;</span>\n"</span></span><br><span class="line">     exp_<span class="built_in">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">"fcr_parse_raw"</span> &#123;</span><br><span class="line">        close</span><br><span class="line">        <span class="built_in">exit</span> -<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    timeout &#123;</span><br><span class="line">        close</span><br><span class="line">        <span class="built_in">exit</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    eof &#123;</span><br><span class="line">        catch <span class="built_in">wait</span> result</span><br><span class="line">        <span class="built_in">exit</span> [lindex <span class="variable">$result</span> <span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    -re . &#123;</span><br><span class="line">        exp_<span class="built_in">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
</div></article></div></section><footer><div class="paginator"><a href="/2013/03/maven-coordinates-dependencies/" class="prev">上一篇</a><a href="/2013/01/linux-text-shell/" class="next">下一篇</a></div><div data-thread-key="2013/01/linux-process-shell/" data-title="Shell常用命令 进程操作篇" data-url="http://hongweiyi.com/2013/01/linux-process-shell/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"yihongwei"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://hongweiyi.com">Hongwei Yi</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-66911097-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>