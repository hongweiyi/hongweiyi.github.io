<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Shell常用命令 文本操作篇 · 小e的笔记</title><meta name="description" content="3.0 前言《Linux/Unix设计思想》中有一条准则：采用纯文本文件来存储数据，原因如下：

文本是通用的可转换格式
文本文件易于阅读和编辑
文本数据文件简化了Unix工具的使用
可移植性的提高克服了速度的不足
速度欠佳的缺点会被明年的机器克服

在实战中有能感受到，文本文件的方便，也有非常多的工具辅助开发者处理、查看、编辑它们，如：awk、sed等，这篇博文就介绍与文本操作相关的常用命令。

3.1 输入输出流echo：echo如同python中的print，不过不需要引号包住字符串，echo后接的除管理和重定向字符外均会输出。
cat（Concatenate）：它主要的功能是将文件的内容连续（concatenate）的输出到屏幕上，在上篇博文中就已经看到了，用来合并多个split的文件。
|：管道符号，接收管道左边命令的输出，并输入到右边的命令。在L"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="http://weibo.com/1674333040" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://twitter.com/hongwei89" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Shell常用命令 文本操作篇</h1><div class="post-meta"><div class="post-time">Jan 19, 2013 | [<a class="tag-link" href="/tags/Linux/">Linux</a>, <a class="tag-link" href="/tags/Shell/">Shell</a>]</div></div><div class="post-content"><h3 id="3-0_前言">3.0 前言</h3><p>《Linux/Unix设计思想》中有一条准则：采用纯文本文件来存储数据，原因如下：</p>
<ol>
<li>文本是通用的可转换格式</li>
<li>文本文件易于阅读和编辑</li>
<li>文本数据文件简化了Unix工具的使用</li>
<li>可移植性的提高克服了速度的不足</li>
<li>速度欠佳的缺点会被明年的机器克服</li>
</ol>
<p>在实战中有能感受到，文本文件的方便，也有非常多的工具辅助开发者处理、查看、编辑它们，如：awk、sed等，这篇博文就介绍与文本操作相关的常用命令。</p>
<a id="more"></a>
<h3 id="3-1_输入输出流">3.1 输入输出流</h3><h4 id="echo：">echo：</h4><p>echo如同python中的print，不过不需要引号包住字符串，echo后接的除管理和重定向字符外均会输出。</p>
<h4 id="cat（Concatenate）：">cat（Concatenate）：</h4><p>它主要的功能是将文件的内容连续（concatenate）的输出到屏幕上，在上篇博文中就已经看到了，用来合并多个split的文件。</p>
<h4 id="|：">|：</h4><p>管道符号，接收管道左边命令的输出，并输入到右边的命令。在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同。在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。</p>
<p>这样，左边命令将数据写到索引节点，右边读取索引节点，读完之后方能继续写。详细实现机制可参考：<a href="http://oss.org.cn/kernel-book/ch07/7.1.1.htm" target="_blank" rel="external">Linux管道的实现机制</a></p>
<h4 id="输出重定向：">输出重定向：</h4><p><code>&gt;</code>: 将左边的输出输入到右边的文件</p>
<p><code>&gt;&gt;</code>: 将左边命令的输出追加输入到右边的文件</p>
<h4 id="标准输出流重定向：">标准输出流重定向：</h4><p>0、1、2分别代表了标准输入、标准输出、标准错误信息输出，实战中经常会将错误输出重定向到标准输出中，可用 2&gt;&amp;1。同时，linux中有特殊的文件，/dev/null可理解为回收站，所有输出输入到该文件中均会“消失”。</p>
<h4 id="read:">read:</h4><p><code>Usage: read [option] [var(default:REPLY)]</code></p>
<p>从标准输出流中读取一行，并给一个变量赋值。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>echo <span class="string">"hello world"</span> &gt; new.txt</span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>cat new.txt</span><br><span class="line">hello world</span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>echo <span class="string">"again"</span> &gt;&gt; new.txt</span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>cat new.txt</span><br><span class="line">hello world</span><br><span class="line">again</span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>echo <span class="string">"col1 col2"</span> | awk <span class="string">'&#123;print $1&#125;'</span></span><br><span class="line">col1</span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>read newline &lt; new.txt; echo <span class="variable">$newline</span></span><br><span class="line">hello world</span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>read &lt; new.txt; echo <span class="variable">$REPLY</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TIPS1: read最常见的应该是用在while循环中了，cat file | while read line; do do_sth; done;</p>
<p>TIPS2: 2&gt;&amp;1常见的地方是用在定时任务中，将所有输出结果均输出到/dev/null中，/bin/sh your.sh &gt; /dev/null 2&gt;&amp;1</p>
<p>TIPS3: Linux中最快的创建空文件的方法不是touch，而是”&gt; newfile”</p>
</blockquote>
<h3 id="3-2_文本查看">3.2 文本查看</h3><p>cat、head、tail、more、less均是查看文本的好工具，有时候结合起来效果会更好。</p>
<h4 id="head(tail)：">head(tail)：</h4><p>查看文件首（尾）十行</p>
<h4 id="more：">more：</h4><p>先显示文件一屏，再等待用户输入，回车是再显示下一行，空格是下一屏，q(ctrl+c)则退出</p>
<h4 id="less：">less：</h4><p>类似more，不过可以往上翻。可用上下键，也可以用u(up)，d(down)键。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>tail -n <span class="number">1000</span> file | more    <span class="comment"># 查看文件的最后1k行</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>head -n <span class="number">10010</span> file | tail     <span class="comment"># 查看文件的第10k行</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>head -c <span class="number">1</span>(b|k|m) file    <span class="comment"># 查看文件的前1B|K|M数据</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3_文本字符集">3.3 文本字符集</h3><p>字符集一直开发者的一个痛，按照东犇的说法是，要废除除utf8外所有字符集。此话虽然暴力，但是也有道理，不过要实现这个想法也基本是不太可能。开发者就只能一步一个脚印的走了。</p>
<h4 id="file:">file:</h4><p>这是查看文本字符串的命令，不过个人觉得，基本不靠谱。因为要查看的数据都是代码生成的，输出的数据也不会有BOM信息，file也没有实现自检测文本字符功能。所以，现实中一般就是连蒙带猜了，不是gbk就是utf8。哈哈</p>
<h4 id="iconv:">iconv:</h4><p>字符集转换工具</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>iconv -f from_code -t to_code file</span><br></pre></td></tr></table></figure>
<p>文本字符集转换在这篇文章就只能点到为止了，字符集的问题三两句话基本讲不清楚，改天有机会单独写篇文章讲讲。</p>
<blockquote>
<p>TIPS1: 输出文本到屏幕，显示的字符集是由终端所设置的。当出现乱码的时候，不要误认为是数据出错了，很有可能就是你的字符集设置有问题。</p>
<p>TIPS2: 按照东犇的说法，建议开发者统一使用utf8编码。他也提供了一种较为方便的查看gbk文本的方法。</p>
</blockquote>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; $ <span class="keyword">echo</span> -<span class="keyword">e</span> <span class="string">"\n"</span>alias conv_gbk=\<span class="string">"iconv -f gbk -t utf8\"</span> &gt;&gt; ~/.bashrc&gt;&gt; $ <span class="keyword">source</span> ~/.bashrc&gt;&gt; $ <span class="keyword">cat</span> <span class="keyword">file</span> | conv_gbk</span><br></pre></td></tr></table></figure>
<h3 id="3-4_文本其他工具">3.4 文本其他工具</h3><h4 id="grep:">grep:</h4><p>查找命令，是开发中使用频率非常高的命令。像我们这边，代码就是文档，最好的翻阅文档工具就是grep了。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>grep [pattern] [file]    <span class="comment"># grep是基于正则表达式的，查找file中符合pattern的行</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>grep -v pattern file    <span class="comment"># 查找file中不符合pattern的行</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>grep pattern . -r    <span class="comment"># -r recursive 查找当前目录下所有符合pattern的文件</span></span><br></pre></td></tr></table></figure>
<h4 id="wc:">wc:</h4><p>wordcount工具，表示中国文字基本用不到。可以用其中一个：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>wc -l file    <span class="comment"># 统计file的行数</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>ls . | wc -l    <span class="comment"># 统计当前目录下文件的数目</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>grep pattern file | wc -l    <span class="comment"># 统计file中符合pattern的行数</span></span><br></pre></td></tr></table></figure>
<h4 id="sort:">sort:</h4><p>排序工具：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; $ <span class="keyword">sort</span> -k <span class="keyword">n</span> (-<span class="keyword">n</span>) (-r) <span class="keyword">file</span>   # 按照第<span class="keyword">n</span>列，给<span class="keyword">file</span>排序。-<span class="keyword">n</span> numeric-<span class="keyword">sort</span> -r <span class="literal">reverse</span></span><br><span class="line">&gt;&gt; $ <span class="keyword">ls</span> -<span class="keyword">l</span> . | <span class="keyword">sort</span> -k 5 -<span class="keyword">n</span>    # 列出当前目录的文件，并按文件大小排序</span><br><span class="line">&gt;&gt; $ <span class="keyword">ls</span> -<span class="keyword">l</span> . | <span class="keyword">sort</span> -k5n -k6    # 列出当前目录的文件，并按文件大小及时间排序</span><br></pre></td></tr></table></figure>
<h4 id="uniq:">uniq:</h4><p>去除连续重复行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; $ cat file</span><br><span class="line"><span class="built_in">test</span>1</span><br><span class="line"><span class="built_in">test</span>2</span><br><span class="line"><span class="built_in">test</span>2</span><br><span class="line"><span class="built_in">test</span>1</span><br><span class="line">&gt;&gt; $ uniq file</span><br><span class="line"><span class="built_in">test</span>1</span><br><span class="line"><span class="built_in">test</span>2</span><br><span class="line"><span class="built_in">test</span>1</span><br><span class="line">&gt;&gt; $ sort file | uniq     <span class="comment"># 去除所有重复行</span></span><br><span class="line"><span class="built_in">test</span>1</span><br><span class="line"><span class="built_in">test</span>2</span><br></pre></td></tr></table></figure>
<h4 id="diff_&amp;_patch:">diff &amp; patch:</h4><p>文本比较工具，和svn里面的diff一样。diff的文件较小的话，结果还可以忍受，如果过大，那结果就不是给人看的了，需要让机器来做一些工作了，如做增量拷贝。这个命令就是patch。</p>
<p>命令较为繁琐，且个人用得较少，就直接引用其他文章了：<a href="https://www.ibm.com/developerworks/cn/linux/l-diffp/" target="_blank" rel="external">用diff和patch工具维护源码</a></p>
<h4 id="awk_&amp;_sed:">awk &amp; sed:</h4><p>sed(stream editor)意为流编辑器，我的理解就是它是按行处理。而awk则不仅仅可以按行，还可以按列。想必前面的文章，也看到了不少用awk的命令。两者各有所长，且博大精深啊，也有关于这两个工具的书。笔者在这里也只介绍我常用到的功能。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>echo <span class="string">"col1 col2 col3"</span> | awk <span class="string">'&#123;print $1"\t"$3&#125;'</span>    <span class="comment"># $0：输入串 $1：col1 $2：col2 $3：col3 …</span></span><br><span class="line">col1[tab]col3</span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>echo <span class="string">"col1 col2 col3"</span> | awk <span class="string">'&#123;print $1, $3&#125;'</span></span><br><span class="line">col1[space]col3</span><br><span class="line"><span class="prompt">&gt;&gt;</span> <span class="variable">$ </span>sed -i <span class="string">"s/pattern/replace_pattern/g"</span> file    <span class="comment"># 替换字符串</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>WARNING: 当文本为中文的时候，sed -i “s/char/replace_char/g”替换ascii标点的时候，需要特别注意。因为gbk编码中有些字节会小于128，而sed替换也是逐字节对比替换，所以有时候会导致中文乱码。</p>
</blockquote>
</div></article></div></section><footer><div class="paginator"><a href="/2013/01/linux-process-shell/" class="prev">上一篇</a><a href="/2013/01/linux-file-directory-shell/" class="next">下一篇</a></div><div data-thread-key="2013/01/linux-text-shell/" data-title="Shell常用命令 文本操作篇" data-url="http://hongweiyi.com/2013/01/linux-text-shell/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"yihongwei"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://hongweiyi.com">Hongwei Yi</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-66911097-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>