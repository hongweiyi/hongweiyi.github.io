<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Shell常用命令 文本操作篇 · 小e的笔记</title><meta name="description" content="3.0 前言
《Linux/Unix设计思想》中有一条准则：&amp;ldquo;采用纯文本文件来存储数据&amp;rdquo;，原因如下：

文本是通用的可转换格式
文本文件易于阅读和编辑
文本数据文件简化了Unix工具的使用
可移植性的提高克服了速度的不足
速度欠佳的缺点会被明年的机器克服

在实战中有能感受到，文本文件的方便，也有非常多的工具辅助开发者处理、查看、编辑它们，如：awk、sed等，这篇博文就介绍与文本操作相关的常用命令。

3.1 输入输出流
echo：
echo如同python中的print，不过不需要引号包住字符串，echo后接的除管理和重定向字符外均会输出。
cat（Concatenate）：
它主要的功能是将文件的内容连续（concatenate）的输出到屏幕上，在上篇博文中就已经看到了，用来合并多个split的文件。
|：
管道符号，接收管道左边命令的输出，并输入到右边的命令。在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同。在 Linux "><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="http://weibo.com/1674333040" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://twitter.com/hongwei89" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Shell常用命令 文本操作篇</h1><div class="post-meta"><div class="post-time">Jan 19, 2013 | [<a class="tag-link" href="/tags/Linux/">Linux</a>, <a class="tag-link" href="/tags/Shell/">Shell</a>]</div></div><div class="post-content"><p>3.0 前言</p>
<p>《Linux/Unix设计思想》中有一条准则：&ldquo;采用纯文本文件来存储数据&rdquo;，原因如下：</p>
<ol>
<li>文本是通用的可转换格式</li>
<li>文本文件易于阅读和编辑</li>
<li>文本数据文件简化了Unix工具的使用</li>
<li>可移植性的提高克服了速度的不足</li>
<li>速度欠佳的缺点会被明年的机器克服</li>
</ol>
<p>在实战中有能感受到，文本文件的方便，也有非常多的工具辅助开发者处理、查看、编辑它们，如：awk、sed等，这篇博文就介绍与文本操作相关的常用命令。</p>
<a id="more"></a>
<p>3.1 输入输出流</p>
<p>echo：</p>
<p>echo如同python中的print，不过不需要引号包住字符串，echo后接的除管理和重定向字符外均会输出。</p>
<p>cat（Concatenate）：</p>
<p>它主要的功能是将文件的内容连续（concatenate）的输出到屏幕上，在上篇博文中就已经看到了，用来合并多个split的文件。</p>
<p>|：</p>
<p>管道符号，接收管道左边命令的输出，并输入到右边的命令。在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同。在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。</p>
<p>这样，左边命令将数据写到索引节点，右边读取索引节点，读完之后方能继续写。详细实现机制可参考：<a href="http://oss.org.cn/kernel-book/ch07/7.1.1.htm" target="_blank" rel="external">Linux管道的实现机制</a></p>
<p>输出重定向：</p>
<p>&gt;: 将左边的输出输入到右边的文件</p>
<p>&gt;&gt;: 将左边命令的输出追加输入到右边的文件</p>
<p>标准输出流重定向：</p>
<p>0、1、2分别代表了标准输入、标准输出、标准错误信息输出，实战中经常会将错误输出重定向到标准输出中，可用 2&gt;&amp;1。同时，linux中有特殊的文件，/dev/null可理解为回收站，所有输出输入到该文件中均会&ldquo;消失&rdquo;。</p>
<p>read:</p>
<p>Usage: read [option] [var(default:REPLY)]</p>
<p>从标准输出流中读取一行，并给一个变量赋值。</p>
<table border="1" cellpadding="0" cellspacing="0" width="619"><br><tbody><br>    <tr><br>        <td valign="top" width="617"><br><br>                &nbsp; &gt;&gt; $ echo &quot;hello world&quot; &gt; new.txt<br><br>                &nbsp; &gt;&gt; $ cat new.txt<br><br>                &nbsp; hello world<br><br>                &nbsp; &gt;&gt; $ echo &quot;again&quot; &gt;&gt; new.txt<br><br>                &nbsp; &gt;&gt; $ cat new.txt<br><br>                &nbsp; hello world<br><br>                &nbsp; again<br><br>                &nbsp; &gt;&gt; $ echo &quot;col1 col2&quot; | awk &#39;{print $1}&#39;<br><br>                &nbsp; col1<br><br>                &nbsp; &gt;&gt; $ read newline &lt; new.txt; echo $newline<br><br>                &nbsp; hello world<br><br>                &nbsp; &gt;&gt; $ read &lt; new.txt; echo $REPLY<br><br>                &nbsp; hello world<br><br>        </td><br>    </tr><br></tbody><br></table>

<blockquote>
<p>TIPS1: read最常见的应该是用在while循环中了，cat file | while read line; do do_sth; done;</p>
<pre><code><span class="string">TIPS2:</span> <span class="number">2</span>&amp;gt;&amp;amp;<span class="number">1</span>常见的地方是用在定时任务中，将所有输出结果均输出到<span class="regexp">/dev/</span><span class="literal">null</span>中，<span class="regexp">/bin/</span>sh your.sh &amp;gt; <span class="regexp">/dev/</span><span class="literal">null</span> <span class="number">2</span>&amp;gt;&amp;amp;<span class="number">1</span>
<span class="label">

TIPS3:</span> Linux中最快的创建空文件的方法不是touch，而是&amp;quot;&amp;gt; newfile&amp;quot;。哈哈，贱笑贱笑。
</code></pre></blockquote>
<pre><code>&amp;nbsp;

3.2&amp;nbsp;文本查看

<span class="keyword">cat</span>、head、tail、<span class="keyword">more</span>、less均是查看文本的好工具，有时候结合起来效果会更好。

head(tail)：

查看文件首（尾）十行

<span class="keyword">more</span>：

先显示文件一屏，再等待用户输入，回车是再显示下一行，空格是下一屏，<span class="literal">q</span>(ctrl+c)则退出

less：

类似<span class="keyword">more</span>，不过可以往上翻。可用上下键，也可以用<span class="keyword">u</span>(up)，<span class="literal">d</span>(down)键。
</code></pre><table border="1" cellpadding="0" cellspacing="0" width="629"><br>    <tbody><br>        <tr><br>            <td valign="top" width="627"><br><br>                    &nbsp; &gt;&gt; $ tail -n 1000 file | more&nbsp;&nbsp;&nbsp; # 查看文件的最后1k行<br><br>                    &nbsp; &gt;&gt; $ head -n 10010 file | tail&nbsp;&nbsp;&nbsp;&nbsp; # 查看文件的第10k行<br><br>                    &nbsp; &gt;&gt; $ head -c 1(b|k|m) file&nbsp;&nbsp;&nbsp; # 查看文件的前1B|K|M数据<br><br>            </td><br>        </tr><br>    </tbody><br></table>

<pre><code>&amp;nbsp;

<span class="number">3.3</span>&amp;nbsp;文本字符集

字符集一直开发者的一个痛，按照东犇的说法是，要废除除utf8外所有字符集。此话虽然暴力，但是也有道理，不过要实现这个想法也基本是不太可能。开发者就只能一步一个脚印的走了。

<span class="type">file</span>:

这是查看文本字符串的命令，不过个人觉得，基本不靠谱。因为要查看的数据都是代码生成的，输出的数据也不会有BOM信息，<span class="type">file</span>也没有实现自检测文本字符功能。所以，现实中一般就是连蒙带猜了，不是gbk就是utf8。哈哈

iconv:

字符集转换工具
</code></pre><table border="1" cellpadding="0" cellspacing="0" width="632"><br>    <tbody><br>        <tr><br>            <td valign="top" width="630"><br><br>                    &nbsp; &gt;&gt; $ iconv -f from_code -t to_code file<br><br>            </td><br>        </tr><br>    </tbody><br></table>

<pre><code>文本字符集转换在这篇文章就只能点到为止了，字符集的问题三两句话基本讲不清楚，改天有机会单独写篇文章讲讲。
</code></pre><blockquote>
<p>TIPS1: 输出文本到屏幕，显示的字符集是由终端所设置的。当出现乱码的时候，不要误认为是数据出错了，很有可能就是你的字符集设置有问题。</p>
<pre><code>    <span class="attribute">TIPS2</span>: <span class="string">按照东犇的说法，建议开发者统一使用utf8编码。他也提供了一种较为方便的查看gbk文本的方法。</span>

<span class="xml">
<span class="tag">&lt;<span class="title">table</span> <span class="attribute">border</span>=<span class="value">"1"</span> <span class="attribute">cellpadding</span>=<span class="value">"0"</span> <span class="attribute">cellspacing</span>=<span class="value">"0"</span> <span class="attribute">width</span>=<span class="value">"605"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">tbody</span>&gt;</span>

        <span class="tag">&lt;<span class="title">tr</span>&gt;</span>

            <span class="tag">&lt;<span class="title">td</span> <span class="attribute">valign</span>=<span class="value">"top"</span> <span class="attribute">width</span>=<span class="value">"603"</span>&gt;</span>


                    &amp;nbsp; &amp;gt;&amp;gt; $ echo -e &amp;quot;\n&amp;quot;alias conv_gbk=\&amp;quot;iconv -f gbk -t utf8\&amp;quot; &amp;gt;&amp;gt; ~/.bashrc


                    &amp;nbsp; &amp;gt;&amp;gt; $ source ~/.bashrc


                    &amp;nbsp; &amp;gt;&amp;gt; $ cat file | conv_gbk


            <span class="tag">&lt;/<span class="title">td</span>&gt;</span>

        <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>

    <span class="tag">&lt;/<span class="title">tbody</span>&gt;</span>

<span class="tag">&lt;/<span class="title">table</span>&gt;</span></span>
</code></pre></blockquote>
<pre><code>3<span class="class">.4</span>&amp;<span class="tag">nbsp</span>;文本其他工具

<span class="rule"><span class="attribute">grep</span>:<span class="value">

查找命令，是开发中使用频率非常高的命令。像我们这边，代码就是文档，最好的翻阅文档工具就是grep了。</span></span>
</code></pre><table border="1" cellpadding="0" cellspacing="0" width="636"><br>    <tbody><br>        <tr><br>            <td valign="top" width="634"><br><br>                    &nbsp; &gt;&gt; $ grep [pattern] [file]&nbsp;&nbsp;&nbsp; # grep是基于正则表达式的，查找file中符合pattern的行<br><br>                    &nbsp; &gt;&gt; $ grep -v pattern file&nbsp;&nbsp;&nbsp; # 查找file中不符合pattern的行<br><br>                    &nbsp; &gt;&gt; $ grep pattern . -r&nbsp;&nbsp;&nbsp; # -r recursive 查找当前目录下所有符合pattern的文件<br><br>            </td><br>        </tr><br>    </tbody><br></table>

<pre><code><span class="label">wc:</span>

wordcount工具，表示中国文字基本用不到。可以用其中一个：
</code></pre><table border="1" cellpadding="0" cellspacing="0" width="635"><br>    <tbody><br>        <tr><br>            <td valign="top" width="633"><br><br>                    &nbsp; &gt;&gt; $ wc -l file&nbsp;&nbsp;&nbsp; # 统计file的行数<br><br>                    &nbsp; &gt;&gt; $ ls . | wc -l&nbsp;&nbsp;&nbsp; # 统计当前目录下文件的数目<br><br>                    &nbsp; &gt;&gt; $ grep pattern file | wc -l&nbsp;&nbsp;&nbsp; # 统计file中符合pattern的行数<br><br>            </td><br>        </tr><br>    </tbody><br></table>

<pre><code><span class="keyword">sor</span><span class="variable">t:</span>

排序工具：
</code></pre><table border="1" cellpadding="0" cellspacing="0" width="634"><br>    <tbody><br>        <tr><br>            <td valign="top" width="632"><br><br>                    &nbsp; &gt;&gt; $ sort -k n (-n) (-r) file&nbsp;&nbsp; # 按照第n列，给file排序。-n numeric-sort -r reverse<br><br>                    &nbsp; &gt;&gt; $ ls -l . | sort -k 5 -n&nbsp;&nbsp;&nbsp; # 列出当前目录的文件，并按文件大小排序<br><br>                    &nbsp; &gt;&gt; $ ls -l . | sort -k5n -k6&nbsp;&nbsp;&nbsp; # 列出当前目录的文件，并按文件大小及时间排序<br><br>            </td><br>        </tr><br>    </tbody><br></table>

<pre><code><span class="label">uniq:</span>

去除连续重复行：
</code></pre><table border="1" cellpadding="0" cellspacing="0" width="633"><br>    <tbody><br>        <tr><br>            <td valign="top" width="631"><br><br>                    &nbsp; &gt;&gt; $ cat file<br><br>                    &nbsp; test1<br><br>                    &nbsp; test2<br><br>                    &nbsp; test2<br><br>                    &nbsp; test1<br><br>                    &nbsp; &gt;&gt; $ uniq file<br><br>                    &nbsp; test1<br><br>                    &nbsp; test2<br><br>                    &nbsp; test1<br><br>                    &nbsp; &gt;&gt; $ sort file | uniq&nbsp;&nbsp;&nbsp;&nbsp; # 去除所有重复行<br><br>                    &nbsp; test1<br><br>                    &nbsp; test2<br><br>            </td><br>        </tr><br>    </tbody><br></table>

<pre><code>diff &amp;amp; patch:

文本比较工具，和svn里面的diff一样。diff的文件较小的话，结果还可以忍受，如果过大，那结果就不是给人看的了，需要让机器来做一些工作了，如做增量拷贝。这个命令就是patch。

命令较为繁琐，且个人用得较少，就直接引用其他文章了：[<span class="link_label">用diff和patch工具维护源码</span>](<span class="link_url">https://www.ibm.com/developerworks/cn/linux/l-diffp/</span>)

awk &amp;amp; sed:

sed(stream editor)意为流编辑器，我的理解就是它是按行处理。而awk则不仅仅可以按行，还可以按列。想必前面的文章，也看到了不少用awk的命令。两者各有所长，且博大精深啊，也有关于这两个工具的书。笔者在这里也只介绍我常用到的功能。
</code></pre><table border="1" cellpadding="0" cellspacing="0" width="632"><br>    <tbody><br>        <tr><br>            <td valign="top" width="630"><br><br>                    &nbsp; &gt;&gt; $ echo &quot;col1 col2 col3&quot; | awk &#39;{print $1&quot;\t&quot;$3}&#39;&nbsp;&nbsp;&nbsp; # $0：输入串 $1：col1 $2：col2 $3：col3 …<br><br>                    &nbsp; col1[tab]col3<br><br>                    &nbsp; &gt;&gt; $ echo &quot;col1 col2 col3&quot; | awk &#39;{print $1, $3}&#39;<br><br>                    &nbsp; col1[space]col3<br><br>                    &nbsp; &gt;&gt; $ sed -i &quot;s/pattern/replace_pattern/g&quot; file&nbsp;&nbsp;&nbsp; # 替换字符串<br><br>            </td><br>        </tr><br>    </tbody><br></table>

<blockquote>
<p>WARNING: 当文本为中文的时候，sed -i &quot;s/char/replace_char/g&quot;替换ascii标点的时候，需要特别注意。因为gbk编码中有些字节会小于128，而sed替换也是逐字节对比替换，所以有时候会导致中文乱码。</p>
</blockquote>
</div></article></div></section><footer><div class="paginator"><a href="/2013/01/linux-process-shell/" class="prev">上一篇</a><a href="/2013/01/linux-file-directory-shell/" class="next">下一篇</a></div><div data-thread-key="2013/01/linux-text-shell/" data-title="Shell常用命令 文本操作篇" data-url="http://hongweiyi.com/2013/01/linux-text-shell/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"yihongwei"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-66911097-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>