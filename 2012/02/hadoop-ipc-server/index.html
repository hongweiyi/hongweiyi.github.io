<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Hadoop源码 - ipc.Server · 小e的笔记</title><meta name="description" content="1、前言昨天分析了ipc包下的RPC、Client类，今天来分析下ipc.Server。Server类因为是Hadoop自己使用，所以代码结构以及流程都很清晰，可以清楚的看到实例化、停止、运行等过程。

2、Server类结构上面是Server的五个内部类，分别介绍一下：
1）Call
用以存储客户端发来的请求，这个请求会放入一个BlockQueue中；
2）Listener
监听类，用以监听客户端发来的请求。同时Listener下面还有一个静态类，Listener.Reader，当监听器监听到用户请求，便用让Reader读取用户请求。
3）Responder
响应RPC请求类，请求处理完毕，由Responder发送给请求客户端。
4）Connection
连接类，真正的客户端请求读取逻辑在这个类中。
5）Handler
请求（blockQueueCall）处理类，会循环阻塞读取callQueue中的call对象，并对其进行操作。
3、Server初始化
第一篇&lt;a href"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="http://weibo.com/1674333040" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://twitter.com/hongwei89" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Hadoop源码 - ipc.Server</h1><div class="post-meta"><div class="post-time">Feb 27, 2012 | [<a class="tag-link" href="/tags/Hadoop/">Hadoop</a>, <a class="tag-link" href="/tags/RPC/">RPC</a>]</div></div><div class="post-content"><h3 id="1、前言">1、前言</h3><p>昨天分析了ipc包下的RPC、Client类，今天来分析下ipc.Server。Server类因为是Hadoop自己使用，所以代码结构以及流程都很清晰，可以清楚的看到实例化、停止、运行等过程。</p>
<a id="more"></a>
<h3 id="2、Server类结构">2、Server类结构</h3><p>上面是Server的五个内部类，分别介绍一下：</p>
<p>1）Call</p>
<p>用以存储客户端发来的请求，这个请求会放入一个BlockQueue中；</p>
<p>2）Listener</p>
<p>监听类，用以监听客户端发来的请求。同时Listener下面还有一个静态类，Listener.Reader，当监听器监听到用户请求，便用让Reader读取用户请求。</p>
<p>3）Responder</p>
<p>响应RPC请求类，请求处理完毕，由Responder发送给请求客户端。</p>
<p>4）Connection</p>
<p>连接类，真正的客户端请求读取逻辑在这个类中。</p>
<p>5）Handler</p>
<p>请求（blockQueueCall）处理类，会循环阻塞读取callQueue中的call对象，并对其进行操作。</p>
<p>3、Server初始化</p>
<p>第一篇<a href="http://www.hongweiyi.com/2012/02/hadoop-ipc-rpc/" target="_blank" rel="external">博客</a>说了，Server的初始化入口在RPC.getServer中，getServer其实是调用的RPC.Server静态类中的构造方法，我们看看Namenode创建RPCServer的方法和RPC.Server构造方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Configuration conf)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    …  </span><br><span class="line">    <span class="keyword">this</span>.serviceRpcServer = RPC.getServer(<span class="keyword">this</span>, dnSocketAddr.getHostName(),   </span><br><span class="line">          dnSocketAddr.getPort(), serviceHandlerCount,  </span><br><span class="line">          <span class="keyword">false</span>, conf, namesystem.getDelegationTokenSecretManager());  </span><br><span class="line">    <span class="keyword">this</span>.serviceRpcServer.start(); <span class="comment">// 运行服务器  </span></span><br><span class="line">&#125;  </span><br><span class="line">```         </span><br><span class="line"></span><br><span class="line">``` <span class="function">java</span><br><span class="line"><span class="keyword">public</span> <span class="title">Server</span><span class="params">(Object instance, Configuration conf, String bindAddress,  <span class="keyword">int</span> port,  </span><br><span class="line">                  <span class="keyword">int</span> numHandlers, <span class="keyword">boolean</span> verbose,   </span><br><span class="line">                  SecretManager&lt;? extends TokenIdentifier&gt; secretManager)</span>   </span><br><span class="line">        <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">      <span class="keyword">super</span>(bindAddress, port, Invocation.class, numHandlers, conf,  </span><br><span class="line">          classNameBase(instance.getClass().getName()), secretManager);  </span><br><span class="line">      <span class="keyword">this</span>.instance = instance;  </span><br><span class="line">      <span class="keyword">this</span>.verbose = verbose;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法调用了父类的构造方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Server</span><span class="params">(String bindAddress, <span class="keyword">int</span> port,   </span><br><span class="line">                  Class&lt;? extends Writable&gt; paramClass, <span class="keyword">int</span> handlerCount,   </span><br><span class="line">                  Configuration conf, String serverName, SecretManager&lt;? extends TokenIdentifier&gt; secretManager)</span>   </span><br><span class="line">    <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.bindAddress = bindAddress;  </span><br><span class="line">    <span class="keyword">this</span>.conf = conf;  </span><br><span class="line">    <span class="keyword">this</span>.port = port;  </span><br><span class="line">    <span class="keyword">this</span>.paramClass = paramClass;  </span><br><span class="line">    <span class="keyword">this</span>.handlerCount = handlerCount;  </span><br><span class="line">    <span class="keyword">this</span>.socketSendBufferSize = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">this</span>.maxQueueSize = handlerCount * conf.getInt(  </span><br><span class="line">                                IPC_SERVER_HANDLER_QUEUE_SIZE_KEY,  </span><br><span class="line">                                IPC_SERVER_HANDLER_QUEUE_SIZE_DEFAULT);  </span><br><span class="line">    <span class="keyword">this</span>.maxRespSize = conf.getInt(IPC_SERVER_RPC_MAX_RESPONSE_SIZE_KEY,  </span><br><span class="line">                                   IPC_SERVER_RPC_MAX_RESPONSE_SIZE_DEFAULT);  </span><br><span class="line">    <span class="keyword">this</span>.readThreads = conf.getInt(  </span><br><span class="line">        IPC_SERVER_RPC_READ_THREADS_KEY,  </span><br><span class="line">        IPC_SERVER_RPC_READ_THREADS_DEFAULT);  </span><br><span class="line">    <span class="keyword">this</span>.callQueue  = <span class="keyword">new</span> LinkedBlockingQueue&lt;Call&gt;(maxQueueSize);   </span><br><span class="line">    <span class="keyword">this</span>.maxIdleTime = <span class="number">2</span>*conf.getInt(<span class="string">"ipc.client.connection.maxidletime"</span>, <span class="number">1000</span>);  </span><br><span class="line">    <span class="keyword">this</span>.maxConnectionsToNuke = conf.getInt(<span class="string">"ipc.client.kill.max"</span>, <span class="number">10</span>);  </span><br><span class="line">    <span class="keyword">this</span>.thresholdIdleConnections = conf.getInt(<span class="string">"ipc.client.idlethreshold"</span>, <span class="number">4000</span>);  </span><br><span class="line">    <span class="keyword">this</span>.secretManager = (SecretManager&lt;TokenIdentifier&gt;) secretManager;  </span><br><span class="line">    <span class="keyword">this</span>.authorize =   </span><br><span class="line">      conf.getBoolean(HADOOP_SECURITY_AUTHORIZATION, <span class="keyword">false</span>);  </span><br><span class="line">    <span class="keyword">this</span>.isSecurityEnabled = UserGroupInformation.isSecurityEnabled();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the listener here and let it bind to the port  </span></span><br><span class="line">    listener = <span class="keyword">new</span> Listener();  </span><br><span class="line">    <span class="keyword">this</span>.port = listener.getAddress().getPort();      </span><br><span class="line">    <span class="keyword">this</span>.rpcMetrics = RpcInstrumentation.create(serverName, <span class="keyword">this</span>.port);  </span><br><span class="line">    <span class="keyword">this</span>.tcpNoDelay = conf.getBoolean(<span class="string">"ipc.server.tcpnodelay"</span>, <span class="keyword">false</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the responder here  </span></span><br><span class="line">    responder = <span class="keyword">new</span> Responder();  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSecurityEnabled) &#123;  </span><br><span class="line">      SaslRpcServer.init(conf);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出，父类的构造方法就初始化了一些配置和变量。</p>
<h3 id="4、Server运行">4、Server运行</h3><p>在上面第一段代码中，还有一句RpcServer.start()的方法，在调用构造函数初始化一些变量之后，Server就可以正式运行起来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    responder.start();  </span><br><span class="line">    listener.start();  </span><br><span class="line">    handlers = <span class="keyword">new</span> Handler[handlerCount];  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; handlerCount; i++) &#123;  </span><br><span class="line">      handlers[i] = <span class="keyword">new</span> Handler(i);  </span><br><span class="line">      handlers[i].start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>responder、listener、handlers三个对象的线程均阻塞了，前两个阻塞在selector.select()方法上，handler阻塞在callQueue.take()方法，都在等待客户端请求。Responder设置了超时时间，为15分钟。而listener还开启了Reader线程，该线程也阻塞了。</p>
<h3 id="4、Server接受请求流程">4、Server接受请求流程</h3><p>1）监听到请求</p>
<p>Listener监听到请求，获得所有请求的SelectionKey，执行doAccept(key)方法，该方法将所有的连接对象放入list中，并将connection对象与key绑定，以供reader使用。初始化玩所有的conne对象之后，就可以激活Reader线程了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException,  OutOfMemoryError </span>&#123;  </span><br><span class="line">      Connection c = <span class="keyword">null</span>;  </span><br><span class="line">      ServerSocketChannel server = (ServerSocketChannel) key.channel();  </span><br><span class="line">      SocketChannel channel;  </span><br><span class="line">      <span class="keyword">while</span> ((channel = server.accept()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);  </span><br><span class="line">        channel.socket().setTcpNoDelay(tcpNoDelay);  </span><br><span class="line">        Reader reader = getReader();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">          reader.startAdd();  <span class="comment">// 激活readSelector，设置adding为true  </span></span><br><span class="line">          SelectionKey readKey = reader.registerChannel(channel);  </span><br><span class="line">          c = <span class="keyword">new</span> Connection(readKey, channel, System.currentTimeMillis());  </span><br><span class="line">          readKey.attach(c);  </span><br><span class="line">          <span class="keyword">synchronized</span> (connectionList) &#123;  </span><br><span class="line">            connectionList.add(numConnections, c);  </span><br><span class="line">            numConnections++;  </span><br><span class="line">          &#125;  </span><br><span class="line">          …           </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">          reader.finishAdd(); <span class="comment">// add完毕，设置adding为false，Reader开始工作  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）接收请求</p>
<p>Reader的run方法和Listener基本一致，也是获得所有的SelectionKey，再执行doRead(key)方法。该方法获得key中绑定的connection，并执行conection的readAndProcess()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;  </span><br><span class="line">      Connection c = (Connection)key.attachment(); <span class="comment">// 获得连接对象  </span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;    </span><br><span class="line">      &#125;  </span><br><span class="line">      c.setLastContact(System.currentTimeMillis());  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;  </span><br><span class="line">        count = c.readAndProcess(); <span class="comment">// 接受并处理请求  </span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ieo) &#123;  </span><br><span class="line">        …  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        …  </span><br><span class="line">        closeConnection(c);  </span><br><span class="line">        c = <span class="keyword">null</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">else</span> &#123;  </span><br><span class="line">        c.setLastContact(System.currentTimeMillis());  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">```            </span><br><span class="line"></span><br><span class="line">``` <span class="function">java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readAndProcess</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;  </span><br><span class="line">    <span class="comment">// 一次最多读取一次RPC请求，如果头没读完，继续迭代直到  </span></span><br><span class="line">    <span class="comment">// 读完所有请求数据    </span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;   </span><br><span class="line">        <span class="keyword">int</span> count = –<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">if</span> (dataLengthBuffer.remaining() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">          count = channelRead(channel, dataLengthBuffer);         </span><br><span class="line">          …  </span><br><span class="line">        <span class="keyword">if</span> (!rpcHeaderRead) &#123;  </span><br><span class="line">          <span class="comment">//读取请求头.  </span></span><br><span class="line">          <span class="keyword">if</span> (rpcHeaderBuffer == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            rpcHeaderBuffer = ByteBuffer.allocate(<span class="number">2</span>);  </span><br><span class="line">          &#125;  </span><br><span class="line">          count = channelRead(channel, rpcHeaderBuffer);  </span><br><span class="line">          <span class="keyword">if</span> (count &lt; <span class="number">0</span> || rpcHeaderBuffer.remaining() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> count;  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="comment">// 读取请求版本号  </span></span><br><span class="line">          <span class="keyword">int</span> version = rpcHeaderBuffer.get(<span class="number">0</span>);  </span><br><span class="line">          <span class="keyword">byte</span>[] method = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;rpcHeaderBuffer.get(<span class="number">1</span>)&#125;;  </span><br><span class="line">          authMethod = AuthMethod.read(<span class="keyword">new</span> DataInputStream(  </span><br><span class="line">              <span class="keyword">new</span> ByteArrayInputStream(method)));  </span><br><span class="line">          dataLengthBuffer.flip();            </span><br><span class="line">          …  </span><br><span class="line">          dataLengthBuffer.clear();  </span><br><span class="line">          …  </span><br><span class="line"></span><br><span class="line">          rpcHeaderBuffer = <span class="keyword">null</span>;  </span><br><span class="line">          rpcHeaderRead = <span class="keyword">true</span>;  </span><br><span class="line">          <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;   </span><br><span class="line">        …  </span><br><span class="line">          data = ByteBuffer.allocate(dataLength);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取请求  </span></span><br><span class="line">        count = channelRead(channel, data);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.remaining() == <span class="number">0</span>) &#123;  </span><br><span class="line">          …  </span><br><span class="line">          <span class="keyword">if</span> (useSasl) &#123;  </span><br><span class="line">            saslReadAndProcess(data.array());  </span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 执行RPC请求，先解析header请求，下次循环解析param请求  </span></span><br><span class="line">            processOneRpc(data.array());  </span><br><span class="line">          &#125;  </span><br><span class="line">          …  </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> count;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）获得call请求</p>
<p>在Connection中解析param请求中，解析了请求数据，并构造Call对象，将其加入callQueue。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">(<span class="keyword">byte</span>[] buf)</span> <span class="keyword">throws</span>  IOException, InterruptedException </span>&#123;  </span><br><span class="line">      DataInputStream dis =  </span><br><span class="line">        <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> ByteArrayInputStream(buf));  </span><br><span class="line">      <span class="keyword">int</span> id = dis.readInt();         <span class="comment">// 读取请求id  </span></span><br><span class="line">        …  </span><br><span class="line"></span><br><span class="line">      Writable param = ReflectionUtils.newInstance(paramClass, conf);<span class="comment">// 获取参数，paramClass是参数的实体类，在构造Server对象的时候传入  </span></span><br><span class="line">      param.readFields(dis);          </span><br><span class="line"></span><br><span class="line">      Call call = <span class="keyword">new</span> Call(id, param, <span class="keyword">this</span>);  </span><br><span class="line">      callQueue.put(call);              <span class="comment">// 添加进阻塞队列，不过队列有max限制，有可能也会阻塞  </span></span><br><span class="line">      incRpcCount();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）处理call对象</p>
<p>Connection给callQueue添加了call对象，阻塞的Handler可以继续运行了，拿出一个call对象，并调用RPC.Call方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键代码  </span></span><br><span class="line"><span class="keyword">while</span> (running) &#123;  </span><br><span class="line">   <span class="keyword">final</span> Call call = callQueue.take(); <span class="comment">// 弹出call对象  </span></span><br><span class="line">   CurCall.set(call);  </span><br><span class="line">   value = call(call.connection.protocol, call.param,   </span><br><span class="line">                         call.timestamp); <span class="comment">// 调用RPC.Server中的call  </span></span><br><span class="line">   CurCall.set(<span class="keyword">null</span>);  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">synchronized</span> (call.connection.responseQueue) &#123;  </span><br><span class="line">       setupResponse(buf, call,   </span><br><span class="line">                      (error == <span class="keyword">null</span>) ? Status.SUCCESS : Status.ERROR,   </span><br><span class="line">                      value, errorClass, error);  </span><br><span class="line">       …  </span><br><span class="line">       responder.doRespond(call);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5）响应请求</p>
<p>上面代码中的setupResponse将call的id和状态发送回去，再设置了call中的response:ByteBuffer，之后就开始responder.doRespond(call)了，processResponse以及Responder.run()没太弄明白，就先不说了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doRespond</span><span class="params">(Call call)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">  <span class="keyword">synchronized</span> (call.connection.responseQueue) &#123;  </span><br><span class="line">    <span class="comment">// 这行没懂  </span></span><br><span class="line">    call.connection.responseQueue.addLast(call);  </span><br><span class="line">    <span class="keyword">if</span> (call.connection.responseQueue.size() == <span class="number">1</span>) &#123;  </span><br><span class="line">      <span class="comment">// 返回响应结果，并激活writeSelector  </span></span><br><span class="line">      processResponse(call.connection.responseQueue, <span class="keyword">true</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6、总结">6、总结</h3><p>Server用的标准的Java TCP/IP NIO通信，同时请求的超时使用基于BlockingQueue以及wait/notify机制实现。使用的模式是reactor模式，关于nio和reactor可以参考这个<a href="http://www.cnblogs.com/ericchen/archive/2011/05/08/2036993.html" target="_blank" rel="external">博客</a>。</p>
<p>对于服务器端接收多个连接请求的需求，Server采用Listener来监听连接的事件，并用Listener.Reader来监听网络流读以及Responder监听写的事件，当有实际的网络流读写时间发生之后，解析了请求Call之后，添加进阻塞队列，并交由多个Handlers来处理请求。</p>
<p>这个方法比TCP/IP BIO好处就是可接受很多的连接，而这些连接只在真实的请求时才会创建线程处理，称之为一请求一处理。但是，连接上的请求发送非常频繁时，TCP/IP NIO的方法并不会带来太大的优势。</p>
<p>但是Hadoop实际场景中，通常是服务器端支持大量的连接数（Namenode连上几千个Datanode），但是连接发送的请求并不会太多（heartbeat、blockreport都有较长间隔）。这样就造成了Hadoop不适合实时的、多请求的运算，带来的代价是模型、实现简单，但是这也为以后的扩展埋下了祸根。</p>
<p>P.S.: 以上分析基于稳定版0.20.203.0rc1。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2012/02/iterative-mapred-summary-haloop/" class="prev">上一篇</a><a href="/2012/02/hadoop-ipc-client/" class="next">下一篇</a></div><div data-thread-key="2012/02/hadoop-ipc-server/" data-title="Hadoop源码 - ipc.Server" data-url="http://hongweiyi.com/2012/02/hadoop-ipc-server/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"yihongwei"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-66911097-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>