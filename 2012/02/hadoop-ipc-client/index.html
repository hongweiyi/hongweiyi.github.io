<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Hadoop源码 - ipc.Client · 小e的笔记</title><meta name="description" content="1**、前言**
上篇博客分析了ipc包下的RPC类，这篇博客来看看Client类吧。  
Hadoop的RPC机制还是挺简单的，简述如下：
1）创建代理对象；
2）代理对象调用相应方法（invoke()）；
3）invoke调用client对象的call方法，向服务器发送请求（参数、方法）；
4）再等待call方法的完成；
5）返回请求结果。
具体是怎么实现的，下面来看看吧。
2**、Client类分析**
有了RPC大致分析，Client我就挑重要的分析了。
1）connections
RPC中就有了ClientCache类，那么client可以复用，所以一个client对象会有多个连接对象，实现中是用HashTable&amp;lt;ConnectionId, Connection&amp;gt;存储的连接对象。
其中，ConnectionId是用来唯一标识连接的ID，主要由客户端地址、时间戳再结合一个素数生成；Connection是Client中的静态内部类，用以"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="http://weibo.com/1674333040" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://twitter.com/hongwei89" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Hadoop源码 - ipc.Client</h1><div class="post-meta"><div class="post-time">Feb 25, 2012</div></div><div class="post-content"><p><strong>1**</strong>、前言**</p>
<p>上篇博客分析了ipc包下的RPC类，这篇博客来看看Client类吧。<br>  <a id="more"></a></p>
<p>Hadoop的RPC机制还是挺简单的，简述如下：</p>
<p>1）创建代理对象；</p>
<p>2）代理对象调用相应方法（invoke()）；</p>
<p>3）invoke调用client对象的call方法，向服务器发送请求（参数、方法）；</p>
<p>4）再等待call方法的完成；</p>
<p>5）返回请求结果。</p>
<p>具体是怎么实现的，下面来看看吧。</p>
<p><strong>2**</strong>、Client类分析**</p>
<p>有了RPC大致分析，Client我就挑重要的分析了。</p>
<p><strong>1）connections</strong></p>
<p>RPC中就有了ClientCache类，那么client可以复用，所以一个client对象会有多个连接对象，实现中是用HashTable&lt;ConnectionId, Connection&gt;存储的连接对象。</p>
<p>其中，ConnectionId是用来唯一标识连接的ID，主要由客户端地址、时间戳再结合一个素数生成；Connection是Client中的静态内部类，用以处理远程连接对象。</p>
<p><strong>2）Call</strong></p>
<p>客户端方法调用的实体类，存放了id、参数、返回值等。需要注意的是，Call类中有callComplete()方法，在一次call调用完毕之后调用，并调用notify()通知client接收完毕。</p>
<p><strong>3）call(Writable param, ConnectionId remoteId)</strong>     <table border="1" cellspacing="0" cellpadding="0"><tbody>       <tr>         <td valign="top" width="568">           <div class="dp-highlighter">             <div class="bar"></div>              </div></td></tr></tbody></table></p>
<ol>
<li><span><span class="keyword">public</span><span> Object invoke(Object proxy, Method method, Object[] args)&#160;&#160; </span></span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">throws</span><span> Throwable {&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; …&#160;&#160; </span></li>
<li><span>&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; ObjectWritable value = (ObjectWritable)&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; client.call(</span><span class="keyword">new</span><span> Invocation(method, args), remoteId); </span><span class="comment">// 调用方法 </span><span>&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; …&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">return</span><span> value.get();&#160;&#160; </span></li>
<li><p><span>&#160;&#160;&#160; }&#160;&#160; </span>                                   <tr>         <td valign="top" width="568">           <div class="dp-highlighter">             <div class="bar"></div>              </div></td></tr></p>
</li>
<li><p><span><span class="comment">// client请求方法 </span><span>&#160; </span></span></p>
</li>
<li><span></span><span class="keyword">public</span><span> Writable call(Writable param, ConnectionId remoteId)&#160;&#160;&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">throws</span><span> InterruptedException, IOException {&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160; Call call = </span><span class="keyword">new</span><span> Call(param);&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160; Connection connection = getConnection(remoteId, call); </span><span class="comment">// 获得连接对象 </span><span>&#160; </span></li>
<li><span>&#160;&#160;&#160; connection.sendParam(call);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span class="comment">// 发送参数 </span><span>&#160; </span></li>
<li><span>&#160;&#160;&#160; …&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160; </span><span class="keyword">synchronized</span><span> (call) {&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">while</span><span> (!call.done) {&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">try</span><span> {&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; call.wait();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span class="comment">// 等待response </span><span>&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } </span><span class="keyword">catch</span><span> (InterruptedException ie) {&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; interrupted = </span><span class="keyword">true</span><span>;&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; }&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; …&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">return</span><span> call.value;&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; …&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160; }&#160;&#160; </span></li>
<li><p><span>&#160; }&#160;&#160; </span>                                   <tr>         <td valign="top" width="568">           <div class="dp-highlighter">             <div class="bar"></div>              </div></td></tr></p>
</li>
<li><p><span><span class="comment">// Connection线程，等待服务器响应 </span><span>&#160; </span></span></p>
</li>
<li><span></span><span class="keyword">public</span><span>&#160;</span><span class="keyword">void</span><span> run() {&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">if</span><span> (LOG.isDebugEnabled())&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; LOG.debug(getName() + </span><span class="string">&quot;: starting, having connections &quot;</span><span>&#160;&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; + connections.size());&#160;&#160; </span></li>
<li><span>&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">while</span><span> (waitForWork()) {</span><span class="comment">// 等待工作，主要依据是calls是否为空 </span><span>&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; receiveResponse();&#160; </span><span class="comment">// 接收响应 </span><span>&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; }&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; close();&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; …&#160;&#160; </span></li>
<li><p><span>&#160;&#160;&#160; }&#160;&#160; </span>                                   <tr>         <td valign="top" width="568">           <div class="dp-highlighter">             <div class="bar"></div>              </div></td></tr></p>
</li>
<li><p><span><span class="keyword">private</span><span>&#160;</span><span class="keyword">void</span><span> receiveResponse() {&#160;&#160; </span></span></p>
</li>
<li><span>&#160;&#160;&#160;&#160;&#160; …&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">try</span><span> {&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">int</span><span> id = in.readInt();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span class="comment">// try to read an id </span><span>&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; …&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Call call = calls.get(id);&#160;&#160; </span></li>
<li><span>&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">int</span><span> state = in.readInt();&#160;&#160;&#160;&#160; </span><span class="comment">// read call status </span><span>&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">if</span><span> (state == Status.SUCCESS.state) {&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Writable value = ReflectionUtils.newInstance(valueClass, conf);&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; value.readFields(in);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span class="comment">// read value </span><span>&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; call.setValue(value);&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; calls.remove(id);&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }&#160;&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; …&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; } </span><span class="keyword">catch</span><span> (IOException e) {&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; markClosed(e);&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; }&#160;&#160; </span></li>
<li><p><span>&#160;&#160;&#160; }&#160;&#160; </span>                                   <tr>         <td valign="top" width="568">           <div class="dp-highlighter">             <div class="bar"></div>              </div></td></tr></p>
</li>
<li><p><span><span class="keyword">public</span><span>&#160;</span><span class="keyword">synchronized</span><span>&#160;</span><span class="keyword">void</span><span> setValue(Writable value) {&#160;&#160; </span></span></p>
</li>
<li><span>&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">this</span><span>.value = value;&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; callComplete();&#160;&#160; </span></li>
<li><span>}&#160;&#160; </span></li>
<li><span></span><span class="keyword">protected</span><span>&#160;</span><span class="keyword">synchronized</span><span>&#160;</span><span class="keyword">void</span><span> callComplete() {&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; </span><span class="keyword">this</span><span>.done = </span><span class="keyword">true</span><span>;&#160;&#160; </span></li>
<li><span>&#160;&#160;&#160;&#160;&#160; notify();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span class="comment">// notify caller </span><span>&#160; </span></li>
<li><span>}&#160;&#160; </span>                                 </li>
</ol>
<p>该方法由invoker调用，调用过程如下：</p>
<p>A、构建Call对象</p>
<p>B、 用remoteId获得connection对象</p>
<p>&#160;&#160;&#160; a) 如果connections中有remoteId，取得该connection；反之，创建一个，并添加进connections；</p>
<p>&#160;&#160;&#160; b) connection.setupIOstreams()连接到服务器，并配置好连接对象，发送协议头，接着运行connection线程，等待接收工作（waitForWork()）；</p>
<p>C、 调用connection.sendParam发送协议体，等待接收响应，call.wait();；</p>
<p>&#160;&#160;&#160; a) receiveResponse()，依次读入call的值（id，value）；</p>
<p>&#160;&#160;&#160; b) 标记接收结束（markClosed），同时notifyAll()；</p>
<p>D、 获得返回值，返回调用者。</p>
<p><strong>3、异步/同步模型</strong></p>
<p>Hadoop的RPC对外的接口其实是同步的，但是，RPC的内部实现其实是异步消息机制。hadoop用线程wait/notify机制实现异步转同步，发送请求（call）之后wait请求处理完毕，接收完响应（connection.receiveResponse()）之后notify，notify()方法在call.setValue中。</p>
<p>但现在有一个问题，一个connection有多个call。可能同时有多个call在等待接收消息，那么是当client接收到response后，怎样确认它到底是之前哪个request的response呢？这个就是依靠的connection中的一个HashTable&lt;Integer, Call&gt;了，其中的Integer是用来标识Call，这样就可以将request和response对应上了。</p>
<p><strong>4、小结</strong></p>
<p>今天先休息一下了，吃坏东西了，悲催。</p>
<blockquote>
<p><strong>参考资料：</strong></p>
<p><a href="http://blog.csdn.net/historyasamirror/article/details/6159248" target="_blank" rel="external">智障大师的专栏</a></p>
</blockquote>
</div></article></div></section><footer><div class="paginator"><a href="/2012/02/hadoop-ipc-server/" class="prev">上一篇</a><a href="/2012/02/hadoop-ipc-rpc/" class="next">下一篇</a></div><div data-thread-key="2012/02/hadoop-ipc-client/" data-title="Hadoop源码 - ipc.Client" data-url="http://hongweiyi.com/2012/02/hadoop-ipc-client/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"yihongwei"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-66911097-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>